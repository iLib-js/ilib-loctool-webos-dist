{"version":3,"sources":["message-accumulator.js"],"names":["whiteSpaceStart","whiteSpaceEnd","whiteSpace","re","first","selfclosing","MessageAccumulator","root","Node","type","parent","index","currentLevel","componentIndex","paramIndex","text","mapping","string","match","lastIndex","parts","split","i","length","exec","parseInt","len","substr","substring","component","extra","_parse","add","subparts","j","value","closed","contents","keep","newNode","console","log","rootnode","children","map","child","toArray","node","use","join","replace","every","_isEmpty","forEach","_renumber","minimized","changed","prefixes","suffixes","subroot","push","concat","slice","last","_getString","_minimize","trim","countCurrentLevel","componentNumber","paramNumber","str","source","ma","getMapping"],"mappings":"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","sourcesContent":["/**\n * message-accumulator.js - accumulate localizable messages\n *\n * @license\n * Copyright © 2019, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Node from 'ilib-tree-node';\n\n// take care of all Unicode whitespace as well as what JS thinks is whitespace\nlet whiteSpaceStart = /^[\\s\\u2000-\\u200D\\u2028\\u2029\\u202F\\u205F\\u2060]+/u;\nlet whiteSpaceEnd = /[\\s\\u2000-\\u200D\\u2028\\u2029\\u202F\\u205F\\u2060]+$/u;\nlet whiteSpace = /[\\s\\u2000-\\u200D\\u2028\\u2029\\u202F\\u205F\\u2060]+/ug;\n\n// use [\\s\\S]*? instead of .* with the \"s\" flag because node 6 and earlier throw errors about the unknown \"s\" flag\nlet re = /(<(c\\d+)>[\\s\\S]*?<\\/\\2>)/g;\nlet first = /^<c(\\d+)>/;\nlet selfclosing = /(<([cp](\\d+))\\/>)/g; // \"c\" for component, \"p\" for parameter\n\n/**\n * MessageAccumulator.js - accumulate a translatable message as a string\n */\nexport default class MessageAccumulator {\n    /**\n     * Create a new accumulator instance.\n     */\n    constructor() {\n        this.root = new Node({\n            type: \"root\",\n            parent: null,\n            index: -1\n        });\n        this.currentLevel = this.root;\n        this.componentIndex = 0;\n        this.paramIndex = 0;\n        this.text = '';\n        this.mapping = {};\n    }\n\n    /**\n     * Factory method to create a new MessageAccumulator instance from\n     * the given string and a source message accumulator. This will\n     * parse the string and create the equivalent tree from it, and\n     * then attach the \"extra\" information from the source accumulator\n     * to the equivalent nodes in the new accumulator. This includes\n     * the source information for components and replacement parameters.\n     *\n     * @param {String} translated the translated string to parse\n     * @param {MessageAccumulator} source the source message\n     * for this translation\n     * @returns {MessageAccumulator} a new message accumulator\n     * instance equivalent to the given string\n     */\n    static create(str, source) {\n        let ma = new MessageAccumulator();\n        if (str) {\n            ma._parse(str, (source && source.getMapping()) || {}, ma.root);\n        }\n        return ma;\n    }\n\n    /**\n     * @private\n     */\n    _parse(string, mapping, parent) {\n        let match;\n\n        re.lastIndex = 0;\n        let parts = string.split(re);\n\n        for (var i = 0; i < parts.length; i++) {\n            first.lastIndex = 0;\n            selfclosing.lastIndex = 0;\n            if ((match = first.exec(parts[i])) !== null) {\n                const index = parseInt(match[1]);\n                const len = match[0].length;\n                // strip off the outer tags before processing the stuff in the middle\n                const substr = parts[i].substring(len, parts[i].length - len - 1);\n                const component = new Node({\n                    type: 'component',\n                    parent,\n                    index,\n                    extra: mapping && mapping[`c${index}`]\n                });\n                this._parse(substr, mapping, component);\n\n                parent.add(component);\n                i++; // skip the number in the next iteration\n            } else if (parts[i] && parts[i].length) {\n                let subparts = parts[i].split(selfclosing);\n                for (var j = 0; j < subparts.length; j++) {\n                    selfclosing.lastIndex = 0;\n                    if ((match = selfclosing.exec(subparts[j])) !== null) {\n                        const index = parseInt(match[3]);\n                        parent.add(new Node({\n                            type: match[2][0] === \"p\" ? 'param' : 'component',\n                            parent,\n                            index,\n                            extra: mapping && mapping[match[2]]\n                        }));\n                        j += 2; // skip the other parts of the match in the next iteration\n                    } else if (subparts[j] && subparts[j].length) {\n                        // don't store empty strings\n                        parent.add(new Node({\n                            type: 'text',\n                            value: subparts[j]\n                        }));\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Add text to the current context of the string.\n     * @param {string} text the text to add\n     */\n    addText(text) {\n        if (typeof text === 'string') {\n            this.currentLevel.add(new Node({\n                type: 'text',\n                value: text\n            }));\n        }\n        this.text += text;\n    }\n\n    /**\n     * Add a replacement parameter to the string. This is a coding\n     * for a replacement parameter in the programming language\n     * or i18n library that does substitutions. By coding the replacement\n     * parameters instead of leaving them in as-is, the strings are\n     * normalized.<p>\n     *\n     * This has two advantages. First, translations for strings\n     * with the same text but different replacement parameter styles\n     * can be shared across i18n libraries. For\n     * example, some libraries use \"C\" style parameters like \"%1s\"\n     * and others use named parameters like \"{name}\". That means\n     * the translation of \"User %1s logged in.\" and of \"User {name}\n     * logged in.\" should have the exact same translation.<p>\n     *\n     * Second, the parameters can be numbered automatically so that\n     * the translator has the freedom to re-arrange the parameters\n     * in a string with multiple parameters as required by the\n     * grammar of the target language. For some parameter styles\n     * that use numbered parameters instead of named ones, the\n     * caller may need to amend original parameter to insert the\n     * number if the original code did not have it already. That\n     * is bad style anyways and you should strongly discourage your\n     * engineers from writing strings with multiple replacement\n     * parameters that are unnumbered.<p>\n     *\n     * Parameters appear in the composed string as XML tags that\n     * are distinct from the component tags. When creating a\n     * translated string, the parameters are substituted back\n     * into the string.\n     *\n     * @param {Object} extra extra information that the caller can\n     * use to identify the original replacement parameter\n     */\n    addParam(extra) {\n        let index = this.paramIndex++;\n        this.currentLevel.add(new Node({\n            type: 'param',\n            index,\n            extra,\n            closed: true\n        }));\n        let contents = `p${index}`;\n        this.text += `<${contents}/>`;\n        this.mapping[contents] = extra;\n    }\n\n    /**\n     * Create a new subcontext for a component such that all text\n     * added to the accumulator goes into the new context.<p>\n     *\n     * A component is represented in the composed string as an\n     * XML tag that is numbered according to the order of the\n     * components in the string. This class maintains a mapping\n     * between the component number and the given \"extra\"\n     * information so that this can be used to create a translated\n     * accumulator with the same extra info. (See the\n     * MessageAccumulator.create static function.)\n     *\n     * @param {Object} extra extra information that the caller would\n     * like to associate with the component. For example, this may\n     * be a node in an AST from parsing the original text.\n     * @param {boolean} keep true if this node should always be kept and\n     * not optimized out during the getMinimalString\n     */\n    push(extra, keep) {\n        const newNode = new Node({\n            type: 'component',\n            parent: this.currentLevel,\n            index: this.componentIndex++,\n            extra,\n            closed: false,\n            keep\n        });\n        this.currentLevel.add(newNode);\n        this.currentLevel = newNode;\n        this.mapping[`c${newNode.index}`] = extra;\n    }\n\n    /**\n     * Pop the current context from the stack and return to the previous\n     * context. If the current context is already the root, then this\n     * represents an unbalanced string.\n     * @returns {Object|undefined} the extra information associated with the\n     * context that is being popped, or undefined if we are already at the\n     * root and there is nothing to pop\n     */\n    pop() {\n        if (!this.currentLevel.parent) {\n            // oh oh, unbalanced?\n            console.log('Unbalanced component error...'); // eslint-disable-line no-console\n            return;\n        }\n        var extra = this.currentLevel.extra;\n        this.currentLevel.closed = true;\n        this.currentLevel = this.currentLevel.parent;\n        return extra;\n    }\n\n    /**\n     * @private\n     */\n    _getString(rootnode) {\n        if (rootnode.children.length === 0) {\n            return rootnode.value || \"\";\n        }\n        return rootnode.children.map(child => {\n            return child.toArray().map(node => {\n                if (node.type === \"component\") {\n                    if (node.index > -1) {\n                        if (node.use === \"start\") {\n                            return `<c${node.index}>`;\n                        } else if (node.use === \"end\") {\n                            return `</c${node.index}>`;\n                        } else {\n                            // self-closing\n                            return `<c${node.index}/>`;\n                        }\n                    }\n                } else if (node.type === \"param\") {\n                    // self-closing\n                    return `<p${node.index}/>`;\n                } else {\n                    return node.value;\n                }\n            }).join('');\n        }).join('');\n    }\n\n    /**\n     * @private\n     */\n    _isEmpty(node) {\n        whiteSpace.lastIndex = 0;\n        if (node.type === \"param\") return false;\n        if (node.type === \"text\" && node.value.replace(whiteSpace, '') !== \"\") return false;\n        if (node.type === \"component\") {\n            if (node.keep) return false;\n            if (node.children && node.children.length) {\n                return node.children.every(child => {\n                    return this._isEmpty(child);\n                });\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @private\n     */\n    _renumber(node) {\n        if (node.type === \"component\") {\n            node.index = this.componentIndex++;\n            this.mapping[`c${node.index}`] = node.extra;\n        } else if (node.type === \"param\") {\n            this.mapping[`p${node.index}`] = node.extra;\n        }\n        if (node.children) {\n            node.children.forEach(child => {\n                this._renumber(child);\n            });\n        }\n    }\n\n    /**\n     * @private\n     */\n    _minimize() {\n        if (this.minimized) return;\n\n        var value, changed = true;\n\n        if (!this.prefixes) this.prefixes = [];\n        if (!this.suffixes) this.suffixes = [];\n\n        // keep stripping off parts until we haven't changed anything, or we have stripped off everything\n        while (changed && this.root.children && this.root.children.length) {\n            changed = false;\n            var subroot = this.root;\n            // check for \"outer\" components -- components that surround localizable text without adding anything to it\n            while (subroot.children && subroot.children.length === 1 && subroot.children[0].type !== \"text\" && !subroot.children[0].keep) {\n                subroot = subroot.children[0];\n                value = new Node(subroot);\n                value.use = \"start\";\n                this.prefixes.push(value);\n                value = new Node(subroot);\n                value.use = \"end\";\n                this.suffixes = [value].concat(this.suffixes);\n\n                changed = true;\n            }\n\n            var children = subroot.children;\n\n            // find empty components at the start\n            var i = 0;\n            while (i < children.length && children[i] && this._isEmpty(children[i])) {\n                this.prefixes = this.prefixes.concat(children[i].toArray());\n                i++;\n                changed = true;\n            }\n\n            children = i > 0 ? children.slice(i) : children;\n\n            // then find empty components at the end\n            var i = children.length - 1;\n            while (i > 0 && children[i] && this._isEmpty(children[i])) {\n                this.suffixes = children[i].toArray().concat(this.suffixes);\n                i--;\n                changed = true;\n            }\n\n            // now strip off the leading and trailing whitespace\n            if (children.length && children[0].type === \"text\") {\n                whiteSpaceStart.lastIndex = 0;\n                var match = whiteSpaceStart.exec(children[0].value);\n                if (match) {\n                    children[0].value = children[0].value.substring(match[0].length);\n                    this.prefixes.push(new Node({\n                        type: \"text\",\n                        value: match[0]\n                    }));\n                    changed = true;\n                }\n            }\n            var last = children.length-1;\n            if (children.length && children[last].type === \"text\") {\n                whiteSpaceEnd.lastIndex = 0;\n                var match = whiteSpaceEnd.exec(children[last].value);\n                if (match) {\n                    children[last].value = children[last].value.substring(0, children[last].value.length - match[0].length);\n                    this.suffixes = [new Node({\n                        type: \"text\",\n                        value: match[0]\n                    })].concat(this.suffixes);\n                    changed = true;\n                }\n            }\n\n            this.root.children = i < children.length - 1 ? children.slice(0, i+1) : children;\n            // then do it all again until nothing changes!\n        }\n\n        // now walk the tree again and renumber any components so that we don't start at some number greater\n        // than zero\n        this.componentIndex = 0;\n        this.mapping = {};\n        this._renumber(this.root);\n\n        this.minimized = true;\n    }\n\n    /**\n     * Return the message accumulated so far, including any components\n     * as a string that contains \"c\" + a number to represent those\n     * components.\n     *\n     * @return {string} the accumulated string so far\n     */\n    getString() {\n        return this._getString(this.root);\n    }\n\n    /**\n     * Return all of the irrelevant parts of the string at the beginning\n     * of the message.<p>\n     *\n     * For a minimal string, all of the components that are irrelevant\n     * for translation are removed. This method returns all of the irrelevant\n     * components and text units that appear at the beginning of the string.\n     *\n     * @returns {Array.<Object>} an array of \"extra\" and text units that\n     * are irrelevant\n     */\n    getPrefix() {\n        this._minimize();\n        return this.prefixes || [];\n    }\n\n    /**\n     * Return the message accumulated so far as a string, including\n     * any components, and leaving out any contexts that are irrelevant\n     * for translation purposes. This method is similar to getString()\n     * with the irrelevant parts removed. This includes:\n     *\n     * <ul>\n     * <li>Any components that surround the entire message\n     * <li>Any components that are at the beginning or end of the message\n     * and which do not have any translatable text in them.\n     * <li>Any text at the beginning or end of the string that only\n     * contains whitespace.\n     * </ul>\n     *\n     * A minimal string must either start with non-whitespace text or end with\n     * non-whitespace text or both.<p>\n     *\n     * After all the irrelevant parts are removed, the remaining components\n     * are renumbered so that the first one to appear starts at zero, the\n     * second one is one, etc.\n     *\n     * @return {string} the accumuilated string so far with all irrelevant\n     * components removed.\n     */\n    getMinimalString() {\n        this._minimize();\n        return this._getString(this.root);\n    }\n\n    /**\n     * Return all of the irrelevant parts of the string at the end\n     * of the message.<p>\n     *\n     * For a minimal string, all of the components that are irrelevant\n     * for translation are removed. This method returns all of the irrelevant\n     * components and text units that appear at the end of the string.\n     *\n     * @returns {Array.<Object>} an array of \"extra\" and text units that\n     * are irrelevant\n     */\n    getSuffix() {\n        this._minimize();\n        return this.suffixes || [];\n    }\n\n    /**\n     * Return the number of characters of non-whitespace text that\n     * have been accumulated so far in this accumulator. Components\n     * are left out.\n     * @return {number} the length of the non-whitespace text accumulated so far\n     */\n    getTextLength() {\n        whiteSpace.lastIndex = 0;\n        return this.text.replace(whiteSpace, '').trim().length;\n    }\n\n    /**\n     * @private\n     * Return the depth of the stack from the given node.\n     */\n    countCurrentLevel(node) {\n        return node.parent ? this.countCurrentLevel(node.parent) + 1 : 0;\n    }\n\n    /**\n     * Return the current depth of the context stack. If the accumulator is\n     * currently at the root, it will return 0.\n     * @returns {number} the current depth of the context stack, or 0 if there\n     * is nothing on the stack yet\n     */\n    getCurrentLevel() {\n        return this.countCurrentLevel(this.currentLevel);\n    }\n\n    /**\n     * Return true if the current context is the root of the message.\n     * @return {boolean} true if the current context is the root\n     */\n    isRoot() {\n        return this.componentIndex === 0;\n    }\n\n    /**\n     * Return the mapping between components and the \"extra\"\n     * information used when creating those components.\n     *\n     * @param {number} componentNumber the number of the\n     * component for which the \"extra\" information is\n     * being sought\n     * @returns {Object} the \"extra\" information that was\n     * given when the component was created\n     */\n    getExtra(componentNumber) {\n        return this.mapping[`c${componentNumber}`];\n    }\n\n    /**\n     * Return the mapping between a replacement parameter\n     * and the \"extra\" information used when creating those\n     * components.\n     *\n     * @param {number} paramNumber the number of the\n     * parameter for which the \"extra\" information is\n     * being sought\n     * @returns {Object} the \"extra\" information that was\n     * given when the parameter was created\n     */\n    getParam(paramNumber) {\n        return this.mapping[`p${paramNumber}`];\n    }\n\n    /**\n     * Return the mappings between component names and\n     * their \"extra\" information they represent.\n     * @returns {Object} the mapping between the\n     * component names and their \"extra\" information.\n     */\n    getMapping() {\n        return this.mapping;\n    }\n}\n"],"file":"message-accumulator-es5.js"}