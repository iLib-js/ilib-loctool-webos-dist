{"version":3,"sources":["TreeNode.js"],"names":["isNode","obj","Node","Object","keys","forEach","key","type","children","child","push","length","ret","clone","use","i","concat","toArray","undefined","array","Array","isArray","every","node","rootExtra","startIndex","root","stack","current","add","pop"],"mappings":"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","sourcesContent":["/**\n * TreeNode.js - build, construct, and deconstruct a tree\n *\n * @license\n * Copyright Â© 2019, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction isNode(obj) {\n    return typeof(obj) === \"object\" && obj instanceof Node;\n}\n\n/**\n * @class Node\n * @param {Object} an object to make into a tree node\n */\nexport default class Node {\n    /**\n     * Create a new node instance.\n     */\n    constructor(obj) {\n        if (obj) {\n            // shallow copy all properties into this node\n            Object.keys(obj).forEach(key => {\n                if (key !== \"children\" && typeof(obj[key]) !== 'undefined') {\n                    this[key] = obj[key];\n                }\n            });\n        } else {\n            this.type = \"text\";\n        }\n        this.children = [];\n    }\n\n    /**\n     * Add a child node to the current context of the tree.\n     * @param {Node} child the child to add\n     */\n    add(child) {\n        if (!isNode(child)) {\n            return;\n        }\n\n        this.children.push(child);\n    }\n\n    /**\n     * Flatten the current node and all of its descendents into an\n     * array and return it. When a node has children, it is\n     * flattened into two nodes: a start node, followed by nodes for\n     * all its children, and an end node. The start and end nodes\n     * are marked by a \"use\" property set to \"start\" and \"end\".\n     *\n     * @returns {Array.<Node>} an array of Nodes flattened from\n     * the current node\n     */\n    toArray() {\n        if (this.children.length) {\n            var ret = [];\n\n            var clone = new Node(this);\n            clone.use = \"start\";\n            ret.push(clone);\n\n            for (var i = 0; i < this.children.length; i++) {\n                ret = ret.concat(this.children[i].toArray());\n            }\n\n            clone = new Node(this);\n            clone.use = \"end\";\n            ret.push(clone);\n\n            return ret;\n        } else if (this.type === \"text\") {\n            this.use = undefined;\n            return [this];\n        } else {\n            // self closing component\n            var clone = new Node(this);\n            clone.use = \"startend\";\n            return [clone];\n        }\n    }\n\n    /**\n     * Recreate a full tree again from a flattened array of Node\n     * instances. If the instances are well-formed (that is,\n     * all start nodes are matched with end nodes with strict\n     * nesting), then the tree is valid. If the array is not\n     * well-formed, then the shape of the resulting tree will\n     * probably not be valid and the results of this static method\n     * are not defined.\n     *\n     * @static\n     * @param {Array.<Node>} array the array of Node instances\n     * to reconstruct into a tree\n     * @returns {Node} a node that is the root of a tree\n     * reconstructed from the array of Nodes\n     */\n    static fromArray(array) {\n        if (!array || !Array.isArray(array) || !array.length) {\n            return undefined;\n        }\n\n        if (!array.every(node => typeof node === \"object\")) {\n            return undefined;\n        }\n\n        var clone;\n        if (array.length === 1) {\n            if (isNode(array[0])) {\n                clone = new Node(array[0]);\n                clone.use = undefined;\n            }\n            return clone;\n        }\n\n        let rootExtra, startIndex = 0;\n        if (array[0].use === \"start\") {\n            rootExtra = array[0];\n            startIndex = 1;\n        } else {\n            rootExtra = {type: \"root\"};\n            startIndex = 0;\n        }\n        // not a tree? Make a wrapper node!\n        let root = new Node(rootExtra);\n        let stack = [];\n        let current = root;\n\n        root.use = undefined;\n        stack.push(root);\n\n        for (var i = startIndex; i < array.length; i++) {\n            if (isNode(array[i])) {\n                if (array[i].use === \"start\") {\n                    clone = new Node(array[i]);\n                    clone.use = undefined;\n                    stack.push(clone);\n                    current.add(clone);\n                    current = clone;\n                } else if (array[i].use === \"end\") {\n                    if (stack.length > 1) {\n                        stack.pop();\n                        current = stack[stack.length-1];\n                    }\n                } else {\n                    current.add(array[i]);\n                }\n            }\n        }\n\n        return root;\n    }\n}\n"],"file":"TreeNode-es5.js"}