"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=void 0;function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor}function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj}}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj}}return _typeof(obj)}/**
 * TreeNode.js - build, construct, and deconstruct a tree
 *
 * @license
 * Copyright Â© 2019, JEDLSoft
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function isNode(obj){return _typeof(obj)==="object"&&obj instanceof Node}/**
 * @class Node
 * @param {Object} an object to make into a tree node
 */var Node=/*#__PURE__*/function(){/**
     * Create a new node instance.
     */function Node(obj){var _this=this;_classCallCheck(this,Node);if(obj){// shallow copy all properties into this node
Object.keys(obj).forEach(function(key){if(key!=="children"&&typeof obj[key]!=="undefined"){_this[key]=obj[key]}})}else{this.type="text"}this.children=[]}/**
     * Add a child node to the current context of the tree.
     * @param {Node} child the child to add
     */_createClass(Node,[{key:"add",value:function add(child){if(!isNode(child)){return}this.children.push(child)}/**
     * Flatten the current node and all of its descendents into an
     * array and return it. When a node has children, it is
     * flattened into two nodes: a start node, followed by nodes for
     * all its children, and an end node. The start and end nodes
     * are marked by a "use" property set to "start" and "end".
     *
     * @returns {Array.<Node>} an array of Nodes flattened from
     * the current node
     */},{key:"toArray",value:function toArray(){if(this.children.length){var ret=[];var clone=new Node(this);clone.use="start";ret.push(clone);for(var i=0;i<this.children.length;i++){ret=ret.concat(this.children[i].toArray())}clone=new Node(this);clone.use="end";ret.push(clone);return ret}else if(this.type==="text"){this.use=undefined;return[this]}else{// self closing component
var clone=new Node(this);clone.use="startend";return[clone]}}/**
     * Recreate a full tree again from a flattened array of Node
     * instances. If the instances are well-formed (that is,
     * all start nodes are matched with end nodes with strict
     * nesting), then the tree is valid. If the array is not
     * well-formed, then the shape of the resulting tree will
     * probably not be valid and the results of this static method
     * are not defined.
     *
     * @static
     * @param {Array.<Node>} array the array of Node instances
     * to reconstruct into a tree
     * @returns {Node} a node that is the root of a tree
     * reconstructed from the array of Nodes
     */}],[{key:"fromArray",value:function fromArray(array){if(!array||!Array.isArray(array)||!array.length){return undefined}if(!array.every(function(node){return _typeof(node)==="object"})){return undefined}var clone;if(array.length===1){if(isNode(array[0])){clone=new Node(array[0]);clone.use=undefined}return clone}var rootExtra,startIndex=0;if(array[0].use==="start"){rootExtra=array[0];startIndex=1}else{rootExtra={type:"root"};startIndex=0}// not a tree? Make a wrapper node!
var root=new Node(rootExtra);var stack=[];var current=root;root.use=undefined;stack.push(root);for(var i=startIndex;i<array.length;i++){if(isNode(array[i])){if(array[i].use==="start"){clone=new Node(array[i]);clone.use=undefined;stack.push(clone);current.add(clone);current=clone}else if(array[i].use==="end"){if(stack.length>1){stack.pop();current=stack[stack.length-1]}}else{current.add(array[i])}}}return root}}]);return Node}();exports["default"]=Node;
//# sourceMappingURL=TreeNode-es5.js.map
